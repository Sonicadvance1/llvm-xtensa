//===-- XtensaISelDAGToDAG.cpp - Define TargetMachine for Xtensa ---------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#include "XtensaTargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/Function.h"

using namespace llvm;

#define DEBUG_TYPE "xtensa-isel"

namespace {

class XtensaDAGToDAGISel : public SelectionDAGISel {
  const XtensaSubtarget *Subtarget;

public:
  explicit XtensaDAGToDAGISel(XtensaTargetMachine &tm,
                               CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(tm, OptLevel), Subtarget(nullptr)
  {}

  StringRef getPassName() const override {
    return "Xtensa Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<XtensaSubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  bool SelectShifted(SDValue N, SDValue &OffImm) {
    SDLoc dl(N);
    N.dump();
    ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(N);
    int64_t RHSC = (int64_t)RHS->getZExtValue();
    OffImm = CurDAG->getTargetConstant(RHSC, dl, MVT::i32);
    return true;
  }

  bool SelectAddrModeIndexed16(SDValue N, SDValue &Base, SDValue &OffImm) {
    return SelectAddrModeIndexed(N, 2, Base, OffImm);
  }

  void Select(SDNode *Node) override;

// Include the pieces autogenerated from the target description.
#include "XtensaGenDAGISel.inc"
private:
  bool SelectAddrModeIndexed(SDValue N, unsigned Size, SDValue &Base,
                             SDValue &OffImm);


};


bool XtensaDAGToDAGISel::SelectAddrModeIndexed(SDValue N, unsigned Size,
                                              SDValue &Base, SDValue &OffImm) {
  SDLoc dl(N);

  if (CurDAG->isBaseWithConstantOffset(N)) {
    if (ConstantSDNode *RHS = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
      int64_t RHSC = (int64_t)RHS->getZExtValue();
      unsigned Scale = Log2_32(Size);
      if ((RHSC & (Size - 1)) == 0 && RHSC >= 0 && RHSC < (0x10 << Scale)) {
        Base = N.getOperand(0);
        OffImm = CurDAG->getTargetConstant(RHSC >> Scale, dl, MVT::i32);
        return true;
      }
    }
  }

  // Base only. The address will be materialized into a register before
  // the memory is accessed.
  //    add x0, Xbase, #offset
  //    ldr x0, [x0]
  Base = N;
  OffImm = CurDAG->getTargetConstant(0, dl, MVT::i32);
  return true;
}

void XtensaDAGToDAGISel::Select(SDNode *Node) {
  llvm::dbgs() << "Attempting to do a select\n";
  Node->dump(CurDAG);
  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << '\n');
    return;
  }

  unsigned Opcode = Node->getOpcode();
  switch (Opcode) {
  default:
    break;
  }

  // Select the default instruction
  SelectCode(Node);
}

}

/// createXtensaISelDag - This pass converts a legalized DAG into a
/// Xtensa-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createXtensaISelDag(XtensaTargetMachine &TM,
                                         CodeGenOpt::Level OptLevel) {
  return new XtensaDAGToDAGISel(TM, OptLevel);
}
